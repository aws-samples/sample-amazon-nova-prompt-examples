{
  "modelId": "us.amazon.nova-pro-v1:0",
  "system": [
    {
      "text": "You are an expert Python programmer who can read code and explain what its doing in very basic terms.\nFollow these instructions:\n1. Read and understand the code written in ## Code ##. Think step by step\n2. Put a 2-3 sentence summary of the code in ## Summary ##\n3. Write an example of how to use the code, using code. Put this example in ## Example ## and use ```python ``` to show the example."
    }
  ],
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "text": "Here's the code:\n## Code ##\nimport time\nimport requests\nimport json\nimport os\nimport random\nimport logging\nfrom typing import Dict, Any, Optional, Union\n\nclass ApiPoller:\n    def __init__(\n        self,\n        endpoint_url: str,\n        output_file: str,\n        base_delay: float = 1.0,\n        max_delay: float = 60.0,\n        max_retries: int = 5,\n        jitter: bool = True,\n        timeout: int = 10,\n        headers: Optional[Dict[str, str]] = None\n    ):\n        self.endpoint_url = endpoint_url\n        self.output_file = output_file\n        self.base_delay = base_delay\n        self.max_delay = max_delay\n        self.max_retries = max_retries\n        self.jitter = jitter\n        self.timeout = timeout\n        self.headers = headers or {}\n        \n        # Set up logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n    \n    def _calculate_delay(self, attempt: int) -> float:\n        delay = min(self.base_delay * (2 ** attempt), self.max_delay)\n        if self.jitter:\n            delay = delay * (0.5 + random.random())\n        return delay\n    \n    def _save_response(self, data: Union[Dict[str, Any], str, bytes]) -> None:\n        try:\n            # Create directory if it doesn't exist\n            os.makedirs(os.path.dirname(os.path.abspath(self.output_file)), exist_ok=True)\n            \n            # Handle different response types\n            if isinstance(data, (dict, list)):\n                with open(self.output_file, 'w', encoding='utf-8') as f:\n                    json.dump(data, f, indent=2)\n            elif isinstance(data, str):\n                with open(self.output_file, 'w', encoding='utf-8') as f:\n                    f.write(data)\n            elif isinstance(data, bytes):\n                with open(self.output_file, 'wb') as f:\n                    f.write(data)\n            \n            self.logger.info(f\"Response successfully saved to {self.output_file}\")\n        except Exception as e:\n            self.logger.error(f\"Failed to save response: {e}\")\n            raise\n    \n    def poll(self, method: str = \"GET\", params: Optional[Dict[str, Any]] = None, \n            data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        attempt = 0\n        last_exception = None\n        \n        while attempt <= self.max_retries:\n            try:\n                self.logger.info(f\"Making {method} request to {self.endpoint_url} (attempt {attempt + 1}/{self.max_retries + 1})\")\n                \n                response = requests.request(\n                    method=method,\n                    url=self.endpoint_url,\n                    params=params,\n                    json=data,\n                    headers=self.headers,\n                    timeout=self.timeout\n                )\n                \n                response.raise_for_status()  # Raise an exception for 4XX/5XX responses\n                \n                result = response.json() if 'application/json' in response.headers.get('Content-Type', '') else response.content\n                \n                self.logger.info(f\"Request successful, status code: {response.status_code}\")\n                self._save_response(result)\n                \n                return result if isinstance(result, dict) else {\"content\": result}\n                \n            except requests.exceptions.RequestException as e:\n                last_exception = e\n                attempt += 1\n                \n                if attempt <= self.max_retries:\n                    delay = self._calculate_delay(attempt - 1)\n                    self.logger.warning(f\"Request failed: {e}. Retrying in {delay:.2f} seconds...\")\n                    time.sleep(delay)\n                else:\n                    self.logger.error(f\"Maximum retries reached. Last error: {e}\")\n                    raise\n        \n        # This should not be reached but just in case\n        if last_exception:\n            raise last_exception\n        raise RuntimeError(\"Failed to poll API for unknown reasons\")"
        }
      ]
    }
  ],
  "inferenceConfig": {
    "temperature": 0.1,
    "topP": 0.99,
    "maxTokens": 512
  }
}